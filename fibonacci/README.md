Défi: Créer un programme qui calcule la suite de Fibonacci dans un langage conçu avant 1980.

Deux solutions sont données.

## 1. INTERCAL
La première est en INTERCAL, un langage conçu en 1972 ayant comme but d'avoir le moins possible de similaire à tout autre langage de programmation du temps. INTERCAL est une abbréviation de "Compiler Language With No Pronounceable Acronym", et est reconnu comme étant le premier langage ésotérique créé.
Le code peut être exécuté en ligne ici: [Try it online!](https://tio.run/##vVhdb9s2FH2OfgUjG1WDpZ4vJdqSMCBIF6c1sDiF46Tbo5O4i4HULmxnRfbgv55d8pISKVF2UBQL0DSiyPtx7rlHJOeLzWx1N318efn0x@D0asBGl5MBmzzM12y@mG/m08f5v7M12zzM2HS1mj6v2dN6ds9un9XQ4/x2NV09B2/hiOn1Z5fsbZxl3SM2Gvw5CQLb7Ojp6@1shYa/PW3w92bJOhDY67qpd10HugwDelh@Z1@ni2f2uFx@W7PH2ZfNMcsB5Ltvq9k/8@XTWg5wOXD3tFrNFpsgQMNy/W/vpDN8kAvwoaUfuH6w44AiCvWnsiCnRWhoi/@ibauI@/xy/GEwYS1wDXBjwh4FPaYcS4MYi5M/ZJkv/4vpfMHO57fLxfTubo4YbB46DERXoTK9v8c6LRds@YVtvi9ZzN/dzjdsobBeu77kA6cH7kSGtuzYaAG3EMrjwI3pbHa3mn1FhOeLv4kLWBR2t3yShGLTxT1bzdab6cp5HxRQIorqwcDvgAdWMKZ2cVOBXOpVca@V58PwZsCuP@FKTqUdD66uLyTHgvLH7YWZSkXhK/viy/xxhoku1vP1Zi1HpxLs2Wp@x4a/Xpqe6KCHuIuwHqCPq8np1UeZ7C@YiPwlgoMi@2M57er6PcZ4oB1/Hg/R83BE72guVOfKQaFoeRJ2YNviohe2WxzJGauX0n2q0Tgg1IoqlxY7sVxJ8ZTWdbsYM4aVZNIYA2s0U6PjwWQ8HCDAbqo6K410ixM0YEMDan4lUygztVlhQoUyVJNE4en0jF1eT2iabwG3IaCHMngTTCVuUHFjGOaFHXvi5lpRgbLaLV3OWD3oMBIXb@AlsgA@vHHGQY3hplqOU8OQkwaKQOybHbV6QsRiG0a4rt1SkschTUQotQ9twB4bOpkS4H24uAuEbar0A/ti5e1OEm2jVrdNg1E9XkJee3CMliEeS6Y4cVWrEteqUrLFoVGdFxQABhu3WzGG1dQg3E80IX/15K@@6QwXztimmWJWq0cPPTchbiXEvTTjP41m/CfQzLXRr7Mm3kmz2F5AzEps63vJFbc7vX3kUngfJu2OkGP9mnH5d/@ojFnWScf8@yXW/nx8eaEWJEc7k/HF12@Hx1wSF8LdOIoKZV3P/aNdRerwHRBQ4MZNz8q519gvFrGqDUgV69sa6VTM5q/4cQf@hnh1h1cbkiKNTlooRm9QjWT3eRs8zYruOn2PLY7fe1OEFItA2@GKBJTf1aTe7XKFRbS0b0qRprUUhiO0iJsM7cwO3LSiVWa3BNq3XCoKd1mmdgaDKxYORpPBmJ2y0fXF@8E4ZBeD0xG7QpJNPg5HH9jZ8Px8MMZJ7PNH/J/9dXldUvAkILPGgUUizMKvRrX29@1DEs/3nBxUxhGAm8RidErS6DRJyo/8OpjYG7KkG5LEp8J@GyoIQ2ycqB29UVPTsB12buSaMAqqqVvY4z5H9OMkaaxH7Gz4sszauaVxDdQGOO3tCH0FD/FbpRgR836vL8GxgD/k@iX04lR91HbuN@2PPrYziIAAra6Rw1m3sUUyapEs834la31Cmy/8MgXVjjLYZfYHQD6L@uYt7Qbk2hQfdjWWDLFBNPbyMkvrvAwPAY@fWnG54Wfm4Wem@WnOV1ofeDf27LwSPyRFvcieQSW1yyM8rhNf0iXKcT0A5I/NikMuWRG15f/YQ9GuV@SwWg3yU8evw83mhLobJ0KzCgOpMNRUOJfVy1X1oKRYHlc@6HqyaU5IGz8kOIfcmZm79Bp@XK8hFQ7Hs6Ka9M7M6lmjTaKrbxU8ouuBx8Nw2Ku84FFe@B@UFzzKm8cIb5KBkFxFDUybIW6WYCgkGPZIMN3SROg1LIoaYswhDWkV7uIQ/ioHQOdAtYly7rxSyzlZVKNNy@37ILfURWgSOqXcUCi3sJUbmpUbSLmhpty5ZItFHm71lqNj@8UcXi3m8EoxB6@YN4Xs47tX0aMctnlV0sEj6WAk/S0XHhHPG0S8KB1ZMOhYIi7vaovLH30bV78M0jtMdYtSmQTOpPqdSUCfneplj/CcVs2RA@VdnjPso4tzxxdDrUHd7b2cY/qQ/pYzK9uc4vIMvwqqp91DKy7jNZyLvY61EbKO9ub459ssVWPi9RM3jvY8csv0jxV0/STmmxWiyEks8TAahSe4Ssi/tYKFjraE7cJA8ROq@aHDTpNJUr/yies3dRY0Zjdhh0k3ITcdOi9Xv1/SjbCgSY7cE7GDm2isMCau9pmYNw/tFMCzE9mqACr7azPm8qtneYfGw6Kzn244QHrPh6rNy6YhpRFl5@TezpECn@9oHeFknXtbR1g0FbtbB70RzVNJ@QpJhNM/JOG0orw@aCPzCiN9bSQ4QH64HRTaIVLYYZ7UTSVmkbLBmLZYM@ZJ1NePwtuPKh3ilsQAtvqKhJxRPuVApEOpBqtX2mMaHL2gvGKxZ1Xq/YZKrjpcPqNVgY@yuSkEx5iyZcWq9zIVB4Scx5ZlxLoB0gtkTmq@Yp9HNIQjGgRgbkRD@ETD3XjEhPgNVdlBXLwK8Zs6ZdTK1yAuwxcWL3aIkdgtRrlHjCptWW@VxEMsq4WdxGhuUpnrdnjPitYjXoXhHJo2PaJBul5eEvEf "INTERCAL – Try It Online")

Le programme peut afficher jusqu'à 45 éléments de la séquence sans causer d'erreur, mais essayer d'entrer 46 ou plus causera un overflow.

## 2. Lambda Calculus
Le **λ-calcul** est un système formel inventé dans les années 1930. Il repose uniquement sur la **définition** et **l’application** de fonctions. Dans ce modèle, **tout est fonction** : une fonction prend une fonction en argument et retourne une fonction.

Par exemple, les nombres y sont représentés sous forme de fonctions : un nombre *n* est une fonction qui applique une autre fonction **n fois** à une valeur (elle-même fonction).
L’implémentation fournie est un fichier **JavaScript** utilisant des fonctions anonymes pour construire l’ensemble du programme.

Pour éviter une récursion infinie, une technique d'évaluation différée est utilisée. Malgré cela, tenter de calculer le 24ᵉ terme ou plus de la séquence provoquera une erreur, due au trop grand nombre d’appels récursifs.

La fonction finale présentée ci-dessous utilise les symboles propres au langage et constitue la vraie réponse #2 au défi. Le fichier JavaScript n’est fourni que pour permettre son exécution.

```
λ n.(λ f.(λ x z.f (x x)) (λ x z.f (x x))) (λ f m.(λ p a b.p a b) ((λ n.n (λ x a b.b) (λ a b.a)) m)
(λ x f x.f x) (λ x.(λ m n.m (λ x f a.f (x f a)) n) (f (λ x a b.a) ((λ n.n (λ g k.(λ n.n (λ x a b.b)
(λ a b.a)) (g (λ f x.f x)) k ((λ m n.m (λ x f a.f (x f a)) n) (g k) (λ f x.f x))) (λ v a b.b) (λ a b.b)) m))
(f (λ x a b.a) ((λ n.n (λ g k.(λ n.n (λ x a b.b) (λ a b.a)) (g (λ f x.f x)) k ((λ m n.m (λ x f a.f (x f a)) n)
(g k) (λ f x.f x))) (λ v a b.b) (λ a b.b)) ((λ n.n (λ g k.(λ n.n (λ x a b.b) (λ a b.a)) (g (λ f x.f x)) k
((λ m n.m (λ x f a.f (x f a)) n) (g k) (λ f x.f x))) (λ v a b.b) (λ a b.b)) m)))) (λ x a b.a)) (λ x a b.a)
((λ n.n (λ g k.(λ n.n (λ x a b.b) (λ a b.a)) (g (λ f x.f x)) k ((λ m n.m (λ x f a.f (x f a)) n) (g k)
(λ f x.f x))) (λ v a b.b) (λ a b.b)) ((λ n.n (λ g k.(λ n.n (λ x a b.b) (λ a b.a)) (g (λ f x.f x)) k
((λ m n.m (λ x f a.f (x f a)) n) (g k) (λ f x.f x))) (λ v a b.b) (λ a b.b)) n))
```
